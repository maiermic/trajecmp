#ifndef BOOST_GEOMETRY_PROJECTIONS_HEALPIX_HPP
#define BOOST_GEOMETRY_PROJECTIONS_HEALPIX_HPP

// Boost.Geometry - extensions-gis-projections (based on PROJ4)
// This file is automatically generated. DO NOT EDIT.

// Copyright (c) 2008-2015 Barend Gehrels, Amsterdam, the Netherlands.

// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// This file is converted from PROJ4, http://trac.osgeo.org/proj
// PROJ4 is originally written by Gerald Evenden (then of the USGS)
// PROJ4 is maintained by Frank Warmerdam
// PROJ4 is converted to Boost.Geometry by Barend Gehrels

// Last updated version of proj: 4.9.1

// Original copyright notice:

// Purpose: Implementation of the HEALPix and rHEALPix projections.
// For background see <http://code.scenzgrid.org/index.php/p/scenzgrid-py/source/tree/master/docs/rhealpix_dggs.pdf>.
// Authors: Alex Raichev (raichev@cs.auckland.ac.nz)
// Michael Speth (spethm@landcareresearch.co.nz)
// Notes:   Raichev implemented these projections in Python and
// Speth translated them into C here.
// Copyright (c) 2001, Thomas Flemming, tf@ttqv.com

// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <boost/geometry/util/math.hpp>

#include <boost/geometry/extensions/gis/projections/impl/base_static.hpp>
#include <boost/geometry/extensions/gis/projections/impl/base_dynamic.hpp>
#include <boost/geometry/extensions/gis/projections/impl/projects.hpp>
#include <boost/geometry/extensions/gis/projections/impl/factory_entry.hpp>
#include <boost/geometry/extensions/gis/projections/impl/pj_auth.hpp>
#include <boost/geometry/extensions/gis/projections/impl/pj_qsfn.hpp>

namespace boost { namespace geometry { namespace projections
{
    #ifndef DOXYGEN_NO_DETAIL
    namespace detail { namespace healpix
    {

            static const double EPS = 1e-15;

            struct par_healpix
            {
                int north_square;
                int south_square;
                double qp;
                double apa[APA_SIZE];
            };

            /* Matrix for counterclockwise rotation by pi/2: */
            /* Matrix for counterclockwise rotation by pi: */
            /* Matrix for counterclockwise rotation by 3*pi/2:  */
            /* Identity matrix */
            /* IDENT, R1, R2, R3, R1 inverse, R2 inverse, R3 inverse:*/
            /* Fuzz to handle rounding errors: */
            typedef struct {
                int cn; /* An integer 0--3 indicating the position of the polar cap. */
                double x, y;  /* Coordinates of the pole point (point of most extreme latitude on the polar caps). */
                enum Region {north, south, equatorial} region;
            } CapMap;
            typedef struct {
                double x, y;
            } Point;
            double rot[7][2][2] = {{{1, 0},{0, 1}}, {{ 0,-1},{ 1, 0}}, {{-1, 0},{ 0,-1}}, {{ 0, 1},{-1, 0}}, {{ 0, 1},{-1, 0}}, {{-1, 0},{ 0,-1}}, {{ 0,-1},{ 1, 0}}};

            /**
             * Returns the sign of the double.
             * @param v the parameter whose sign is returned.
             * @return 1 for positive number, -1 for negative, and 0 for zero.
             **/
            double pj_sign (double v) {
                return v > 0 ? 1 : (v < 0 ? -1 : 0);
            }
            /**
             * Return the index of the matrix in {{{1, 0},{0, 1}}, {{ 0,-1},{ 1, 0}}, {{-1, 0},{ 0,-1}}, {{ 0, 1},{-1, 0}}, {{ 0, 1},{-1, 0}}, {{-1, 0},{ 0,-1}}, {{ 0,-1},{ 1, 0}}}.
             * @param index ranges from -3 to 3.
             */
            static int get_rotate_index(int index) {
                switch(index) {
                case 0:
                    return 0;
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 3:
                    return 3;
                case -1:
                    return 4;
                case -2:
                    return 5;
                case -3:
                    return 6;
                }
                return 0;
            }
            /**
             * Return 1 if point (testx, testy) lies in the interior of the polygon
             * determined by the vertices in vert, and return 0 otherwise.
             * See http://paulbourke.net/geometry/polygonmesh/ for more details.
             * @param nvert the number of vertices in the polygon.
             * @param vert the (x, y)-coordinates of the polygon's vertices
             **/
            static int pnpoly(int nvert, double vert[][2], double testx, double testy) {
                int i, c = 0;
                int counter = 0;
                double xinters;
                Point p1, p2;
                /* Check for boundrary cases */
                for (i = 0; i < nvert; i++) {
                    if (testx == vert[i][0] && testy == vert[i][1]) {
                        return 1;
                    }
                }
                p1.x = vert[0][0];
                p1.y = vert[0][1];
                for (i = 1; i < nvert; i++) {
                    p2.x = vert[i % nvert][0];
                    p2.y = vert[i % nvert][1];
                    if (testy > (std::min)(p1.y, p2.y)) {
                        if (testy <= (std::max)(p1.y, p2.y)) {
                            if (testx <= (std::max)(p1.x, p2.x)) {
                                if (p1.y != p2.y) {
                                    xinters = (testy-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
                                    if (p1.x == p2.x || testx <= xinters) {
                                        counter++;
                                    }
                                }
                            }
                        }
                    }
                    p1 = p2;
                }
                if (counter % 2 == 0) {
                    return 0;
                } else {
                    return 1;
                }
                return c;
            }
            /**
             * Return 1 if (x, y) lies in (the interior or boundary of) the image of the
             * HEALPix projection (in case proj=0) or in the image the rHEALPix projection
             * (in case proj=1), and return 0 otherwise.
             * @param north_square the position of the north polar square (rHEALPix only)
             * @param south_square the position of the south polar square (rHEALPix only)
             **/
            int in_image(double x, double y, int proj, int north_square, int south_square) {
                if (proj == 0) {
                    double healpixVertsJit[][2] = {
                        {-1.0*geometry::math::pi<double>()- EPS, geometry::math::pi<double>()/4.0},
                        {-3.0*geometry::math::pi<double>()/4.0, geometry::math::pi<double>()/2.0 + EPS},
                        {-1.0*geometry::math::pi<double>()/2.0, geometry::math::pi<double>()/4.0 + EPS},
                        {-1.0*geometry::math::pi<double>()/4.0, geometry::math::pi<double>()/2.0 + EPS},
                        {0.0, geometry::math::pi<double>()/4.0 + EPS},
                        {geometry::math::pi<double>()/4.0, geometry::math::pi<double>()/2.0 + EPS},
                        {geometry::math::pi<double>()/2.0, geometry::math::pi<double>()/4.0 + EPS},
                        {3.0*geometry::math::pi<double>()/4.0, geometry::math::pi<double>()/2.0 + EPS},
                        {geometry::math::pi<double>()+ EPS, geometry::math::pi<double>()/4.0},
                        {geometry::math::pi<double>()+ EPS, -1.0*geometry::math::pi<double>()/4.0},
                        {3.0*geometry::math::pi<double>()/4.0, -1.0*geometry::math::pi<double>()/2.0 - EPS},
                        {geometry::math::pi<double>()/2.0, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {geometry::math::pi<double>()/4.0, -1.0*geometry::math::pi<double>()/2.0 - EPS},
                        {0.0, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>()/4.0, -1.0*geometry::math::pi<double>()/2.0 - EPS},
                        {-1.0*geometry::math::pi<double>()/2.0, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-3.0*geometry::math::pi<double>()/4.0, -1.0*geometry::math::pi<double>()/2.0 - EPS},
                        {-1.0*geometry::math::pi<double>() - EPS, -1.0*geometry::math::pi<double>()/4.0}
                    };
                    return pnpoly((int)sizeof(healpixVertsJit)/
                                  sizeof(healpixVertsJit[0]), healpixVertsJit, x, y);
                } else {
                    double rhealpixVertsJit[][2] = {
                        {-1.0*geometry::math::pi<double>() - EPS, geometry::math::pi<double>()/4.0 + EPS},
                        {-1.0*geometry::math::pi<double>() + north_square*geometry::math::pi<double>()/2.0- EPS, geometry::math::pi<double>()/4.0 + EPS},
                        {-1.0*geometry::math::pi<double>() + north_square*geometry::math::pi<double>()/2.0- EPS, 3*geometry::math::pi<double>()/4.0 + EPS},
                        {-1.0*geometry::math::pi<double>() + (north_square + 1.0)*geometry::math::pi<double>()/2.0 + EPS, 3*geometry::math::pi<double>()/4.0 + EPS},
                        {-1.0*geometry::math::pi<double>() + (north_square + 1.0)*geometry::math::pi<double>()/2.0 + EPS, geometry::math::pi<double>()/4.0 + EPS},
                        {geometry::math::pi<double>() + EPS, geometry::math::pi<double>()/4.0 + EPS},
                        {geometry::math::pi<double>() + EPS, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>() + (south_square + 1.0)*geometry::math::pi<double>()/2.0 + EPS, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>() + (south_square + 1.0)*geometry::math::pi<double>()/2.0 + EPS, -3.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>() + south_square*geometry::math::pi<double>()/2.0 - EPS, -3.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>() + south_square*geometry::math::pi<double>()/2.0 - EPS, -1.0*geometry::math::pi<double>()/4.0 - EPS},
                        {-1.0*geometry::math::pi<double>() - EPS, -1.0*geometry::math::pi<double>()/4.0 - EPS}};
                    return pnpoly((int)sizeof(rhealpixVertsJit)/
                                  sizeof(rhealpixVertsJit[0]), rhealpixVertsJit, x, y);
                }
            }
            /**
             * Return the authalic latitude of latitude alpha (if inverse=0) or
             * return the approximate latitude of authalic latitude alpha (if inverse=1).
             * P contains the relavent ellipsoid parameters.
             **/
            template <typename Parameters>
            double auth_lat(const Parameters& par, const par_healpix& proj_parm, double alpha, int inverse) {
                if (inverse == 0) {
                    /* Authalic latitude. */
                    double q = pj_qsfn(sin(alpha), par.e, 1.0 - par.es);
                    double qp = proj_parm.qp;
                    double ratio = q/qp;
                    if (fabsl(ratio) > 1) {
                        /* Rounding error. */
                        ratio = pj_sign(ratio);
                    }
                    return asin(ratio);
                } else {
                    /* Approximation to inverse authalic latitude. */
                    return pj_authlat(alpha, proj_parm.apa);
                }
            }
            /**
             * Return the HEALPix projection of the longitude-latitude point lp on
             * the unit sphere.
            **/
            void healpix_sphere(double const& lp_lam, double const& lp_phi, double& xy_x, double& xy_y) {
                double lam = lp_lam;
                double phi = lp_phi;
                double phi0 = asin(2.0/3.0);

                /* equatorial region */
                if ( fabsl(phi) <= phi0) {
                    xy_x = lam;
                    xy_y = 3.0*geometry::math::pi<double>()/8.0*sin(phi);
                } else {
                    double lamc;
                    double sigma = sqrt(3.0*(1 - fabsl(sin(phi))));
                    double cn = floor(2*lam / geometry::math::pi<double>() + 2);
                    if (cn >= 4) {
                        cn = 3;
                    }
                    lamc = -3*geometry::math::pi<double>()/4 + (geometry::math::pi<double>()/2)*cn;
                    xy_x = lamc + (lam - lamc)*sigma;
                    xy_y = pj_sign(phi)*geometry::math::pi<double>()/4*(2 - sigma);
                }
                return;
            }
            /**
             * Return the inverse of healpix_sphere().
            **/
            void healpix_sphere_inverse(double const& xy_x, double const& xy_y, double& lp_lam, double& lp_phi) {

                double x = xy_x;
                double y = xy_y;
                double y0 = geometry::math::pi<double>()/4.0;
                /* Equatorial region. */
                if (fabsl(y) <= y0) {
                    lp_lam = x;
                    lp_phi = asin(8.0*y/(3.0*geometry::math::pi<double>()));
                } else if (fabsl(y) < geometry::math::pi<double>()/2.0) {
                    double cn = floor(2.0*x/geometry::math::pi<double>() + 2.0);
                    double xc, tau;
                    if (cn >= 4) {
                        cn = 3;
                    }
                    xc = -3.0*geometry::math::pi<double>()/4.0 + (geometry::math::pi<double>()/2.0)*cn;
                    tau = 2.0 - 4.0*fabsl(y)/geometry::math::pi<double>();
                    lp_lam = xc + (x - xc)/tau;
                    lp_phi = pj_sign(y)*asin(1.0 - pow(tau , 2.0)/3.0);
                } else {
                    lp_lam = -1.0*geometry::math::pi<double>();
                    lp_phi = pj_sign(y)*geometry::math::pi<double>()/2.0;
                }
                return;
            }
            /**
             * Return the vector sum a + b, where a and b are 2-dimensional vectors.
             * @param ret holds a + b.
             **/
            static void vector_add(double a[2], double b[2], double *ret) {
                int i;
                for(i = 0; i < 2; i++) {
                    ret[i] = a[i] + b[i];
                }
            }
            /**
             * Return the vector difference a - b, where a and b are 2-dimensional vectors.
             * @param ret holds a - b.
             **/
            static void vector_sub(double a[2], double b[2], double*ret) {
                int i;
                for(i = 0; i < 2; i++) {
                    ret[i] = a[i] - b[i];
                }
            }
            /**
             * Return the 2 x 1 matrix product a*b, where a is a 2 x 2 matrix and
             * b is a 2 x 1 matrix.
             * @param ret holds a*b.
             **/
            static void dot_product(double a[2][2], double b[2], double *ret) {
                int i, j;
                int length = 2;
                for(i = 0; i < length; i++) {
                    ret[i] = 0;
                    for(j = 0; j < length; j++) {
                        ret[i] += a[i][j]*b[j];
                    }
                }
            }
            /**
             * Return the number of the polar cap, the pole point coordinates, and
             * the region that (x, y) lies in.
             * If inverse=0, then assume (x,y) lies in the image of the HEALPix
             * projection of the unit sphere.
             * If inverse=1, then assume (x,y) lies in the image of the
             * (north_square, south_square)-rHEALPix projection of the unit sphere.
             **/
            static CapMap get_cap(double x, double y, int north_square, int south_square,
                                  int inverse) {
                CapMap capmap;
                double c;
                capmap.x = x;
                capmap.y = y;
                if (inverse == 0) {
                    if (y > geometry::math::pi<double>()/4.0) {
                        capmap.region = CapMap::north;
                        c = geometry::math::pi<double>()/2.0;
                    } else if (y < -1*geometry::math::pi<double>()/4.0) {
                        capmap.region = CapMap::south;
                        c = -1*geometry::math::pi<double>()/2.0;
                    } else {
                        capmap.region = CapMap::equatorial;
                        capmap.cn = 0;
                        return capmap;
                    }
                    /* polar region */
                    if (x < -1*geometry::math::pi<double>()/2.0) {
                        capmap.cn = 0;
                        capmap.x = (-1*3.0*geometry::math::pi<double>()/4.0);
                        capmap.y = c;
                    } else if (x >= -1*geometry::math::pi<double>()/2.0 && x < 0) {
                        capmap.cn = 1;
                        capmap.x = -1*geometry::math::pi<double>()/4.0;
                        capmap.y = c;
                    } else if (x >= 0 && x < geometry::math::pi<double>()/2.0) {
                        capmap.cn = 2;
                        capmap.x = geometry::math::pi<double>()/4.0;
                        capmap.y = c;
                    } else {
                        capmap.cn = 3;
                        capmap.x = 3.0*geometry::math::pi<double>()/4.0;
                        capmap.y = c;
                    }
                    return capmap;
                } else {
                    double eps;
                    if (y > geometry::math::pi<double>()/4.0) {
                        capmap.region = CapMap::north;
                        capmap.x = (-3.0*geometry::math::pi<double>()/4.0 + north_square*geometry::math::pi<double>()/2.0);
                        capmap.y = geometry::math::pi<double>()/2.0;
                        x = x - north_square*geometry::math::pi<double>()/2.0;
                    } else if (y < -1*geometry::math::pi<double>()/4.0) {
                        capmap.region = CapMap::south;
                        capmap.x = (-3.0*geometry::math::pi<double>()/4.0 + south_square*geometry::math::pi<double>()/2);
                        capmap.y = -1*geometry::math::pi<double>()/2.0;
                        x = x - south_square*geometry::math::pi<double>()/2.0;
                    } else {
                        capmap.region = CapMap::equatorial;
                        capmap.cn = 0;
                        return capmap;
                    }
                    /* Polar Region, find the HEALPix polar cap number that
                       x, y moves to when rHEALPix polar square is disassembled. */
                    eps = 1e-15; /* Kludge.  Fuzz to avoid some rounding errors. */
                    if (capmap.region == CapMap::north) {
                        if (y >= -1*x - geometry::math::pi<double>()/4.0 - eps && y < x + 5.0*geometry::math::pi<double>()/4.0 - eps) {
                            capmap.cn = (north_square + 1) % 4;
                        } else if (y > -1*x -1*geometry::math::pi<double>()/4.0 + eps && y >= x + 5.0*geometry::math::pi<double>()/4.0 - eps) {
                            capmap.cn = (north_square + 2) % 4;
                        } else if (y <= -1*x -1*geometry::math::pi<double>()/4.0 + eps && y > x + 5.0*geometry::math::pi<double>()/4.0 + eps) {
                            capmap.cn = (north_square + 3) % 4;
                        } else {
                            capmap.cn = north_square;
                        }
                    } else if (capmap.region == CapMap::south) {
                        if (y <= x + geometry::math::pi<double>()/4.0 + eps && y > -1*x - 5.0*geometry::math::pi<double>()/4 + eps) {
                            capmap.cn = (south_square + 1) % 4;
                        } else if (y < x + geometry::math::pi<double>()/4.0 - eps && y <= -1*x - 5.0*geometry::math::pi<double>()/4.0 + eps) {
                            capmap.cn = (south_square + 2) % 4;
                        } else if (y >= x + geometry::math::pi<double>()/4.0 - eps && y < -1*x - 5.0*geometry::math::pi<double>()/4.0 - eps) {
                            capmap.cn = (south_square + 3) % 4;
                        } else {
                            capmap.cn = south_square;
                        }
                    }
                    return capmap;
                }
            }
            /**
             * Rearrange point (x, y) in the HEALPix projection by
             * combining the polar caps into two polar squares.
             * Put the north polar square in position north_square and
             * the south polar square in position south_square.
             * If inverse=1, then uncombine the polar caps.
             * @param north_square integer between 0 and 3.
             * @param south_square integer between 0 and 3.
             **/
            static void combine_caps(double& xy_x, double& xy_y, int north_square, int south_square,
                                   int inverse) {

                double v[2];
                double a[2];
                double vector[2];
                double v_min_c[2];
                double ret_dot[2];
                CapMap capmap = get_cap(xy_x, xy_y, north_square, south_square, inverse);
                if (capmap.region == CapMap::equatorial) {
                    xy_x = capmap.x;
                    xy_y = capmap.y;
                    return;
                }
                v[0] = xy_x;
                v[1] = xy_y;
                if (inverse == 0) {
                    /* Rotate (xy_x, xy_y) about its polar cap tip and then translate it to
                       north_square or south_square. */
                    int pole = 0;
                    double (*tmpRot)[2];
                    double c[2] = {capmap.x, capmap.y};
                    if (capmap.region == CapMap::north) {
                        pole = north_square;
                        a[0] =  (-3.0*geometry::math::pi<double>()/4.0 + pole*geometry::math::pi<double>()/2);
                        a[1] =  (geometry::math::pi<double>()/2.0 + pole*0);
                        tmpRot = rot[get_rotate_index(capmap.cn - pole)];
                        vector_sub(v, c, v_min_c);
                        dot_product(tmpRot, v_min_c, ret_dot);
                        vector_add(ret_dot, a, vector);
                    } else {
                        pole = south_square;
                        a[0] =  (-3.0*geometry::math::pi<double>()/4.0 + pole*geometry::math::pi<double>()/2);
                        a[1] =  (geometry::math::pi<double>()/-2.0 + pole*0);
                        tmpRot = rot[get_rotate_index(-1*(capmap.cn - pole))];
                        vector_sub(v, c, v_min_c);
                        dot_product(tmpRot, v_min_c, ret_dot);
                        vector_add(ret_dot, a, vector);
                    }
                    xy_x = vector[0];
                    xy_y = vector[1];
                    return;
                } else {
                    /* Inverse function.
                     Unrotate (xy_x, xy_y) and then translate it back. */
                    int pole = 0;
                    double (*tmpRot)[2];
                    double c[2] = {capmap.x, capmap.y};
                    /* disassemble */
                    if (capmap.region == CapMap::north) {
                        pole = north_square;
                        a[0] =  (-3.0*geometry::math::pi<double>()/4.0 + capmap.cn*geometry::math::pi<double>()/2);
                        a[1] =  (geometry::math::pi<double>()/2.0 + capmap.cn*0);
                        tmpRot = rot[get_rotate_index(-1*(capmap.cn - pole))];
                        vector_sub(v, c, v_min_c);
                        dot_product(tmpRot, v_min_c, ret_dot);
                        vector_add(ret_dot, a, vector);
                    } else {
                        pole = south_square;
                        a[0] =  (-3.0*geometry::math::pi<double>()/4.0 + capmap.cn*geometry::math::pi<double>()/2);
                        a[1] =  (geometry::math::pi<double>()/-2.0 + capmap.cn*0);
                        tmpRot = rot[get_rotate_index(capmap.cn - pole)];
                        vector_sub(v, c, v_min_c);
                        dot_product(tmpRot, v_min_c, ret_dot);
                        vector_add(ret_dot, a, vector);
                    }
                    xy_x = vector[0];
                    xy_y = vector[1];
                    return;
                }
            }

            // template class, using CRTP to implement forward/inverse
            template <typename Geographic, typename Cartesian, typename Parameters>
            struct base_healpix_ellipsoid : public base_t_fi<base_healpix_ellipsoid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>
            {

                 typedef double geographic_type;
                 typedef double cartesian_type;

                par_healpix m_proj_parm;

                inline base_healpix_ellipsoid(const Parameters& par)
                    : base_t_fi<base_healpix_ellipsoid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>(*this, par) {}

                // FORWARD(e_healpix_forward)  ellipsoid
                // Project coordinates from geographic (lon, lat) to cartesian (x, y)
                inline void fwd(geographic_type& lp_lon, geographic_type& lp_lat, cartesian_type& xy_x, cartesian_type& xy_y) const
                {
                    lp_lat = auth_lat(this->params(), m_proj_parm, lp_lat, 0);
                    return healpix_sphere(lp_lon, lp_lat, xy_x, xy_y);
                }

                // INVERSE(e_healpix_inverse)  ellipsoid
                // Project coordinates from cartesian (x, y) to geographic (lon, lat)
                inline void inv(cartesian_type& xy_x, cartesian_type& xy_y, geographic_type& lp_lon, geographic_type& lp_lat) const
                {
                    /* Check whether (x, y) lies in the HEALPix image. */
                    if (in_image(xy_x, xy_y, 0, 0, 0) == 0) {
                        lp_lon = HUGE_VAL;
                        lp_lat = HUGE_VAL;
                        throw proj_exception(-15);
                            return;
                    }
                    healpix_sphere_inverse(xy_x, xy_y, lp_lon, lp_lat);
                    lp_lat = auth_lat(this->params(), m_proj_parm, lp_lat, 1);
                }

                static inline std::string get_name()
                {
                    return "healpix_ellipsoid";
                }

            };

            // template class, using CRTP to implement forward/inverse
            template <typename Geographic, typename Cartesian, typename Parameters>
            struct base_healpix_spheroid : public base_t_fi<base_healpix_spheroid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>
            {

                 typedef double geographic_type;
                 typedef double cartesian_type;

                par_healpix m_proj_parm;

                inline base_healpix_spheroid(const Parameters& par)
                    : base_t_fi<base_healpix_spheroid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>(*this, par) {}

                // FORWARD(s_healpix_forward)  sphere
                // Project coordinates from geographic (lon, lat) to cartesian (x, y)
                inline void fwd(geographic_type& lp_lon, geographic_type& lp_lat, cartesian_type& xy_x, cartesian_type& xy_y) const
                {
                    return healpix_sphere(lp_lon, lp_lat, xy_x, xy_y);
                }

                // INVERSE(s_healpix_inverse)  sphere
                // Project coordinates from cartesian (x, y) to geographic (lon, lat)
                inline void inv(cartesian_type& xy_x, cartesian_type& xy_y, geographic_type& lp_lon, geographic_type& lp_lat) const
                {
                    /* Check whether (x, y) lies in the HEALPix image */
                    if (in_image(xy_x, xy_y, 0, 0, 0) == 0) {
                        lp_lon = HUGE_VAL;
                        lp_lat = HUGE_VAL;
                        throw proj_exception(-15);
                            return;
                    }
                    return healpix_sphere_inverse(xy_x, xy_y, lp_lon, lp_lat);
                }

                static inline std::string get_name()
                {
                    return "healpix_spheroid";
                }

            };

            // template class, using CRTP to implement forward/inverse
            template <typename Geographic, typename Cartesian, typename Parameters>
            struct base_rhealpix_ellipsoid : public base_t_fi<base_rhealpix_ellipsoid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>
            {

                 typedef double geographic_type;
                 typedef double cartesian_type;

                par_healpix m_proj_parm;

                inline base_rhealpix_ellipsoid(const Parameters& par)
                    : base_t_fi<base_rhealpix_ellipsoid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>(*this, par) {}

                // FORWARD(e_rhealpix_forward)  ellipsoid
                // Project coordinates from geographic (lon, lat) to cartesian (x, y)
                inline void fwd(geographic_type& lp_lon, geographic_type& lp_lat, cartesian_type& xy_x, cartesian_type& xy_y) const
                {
                    lp_lat = auth_lat(this->params(), m_proj_parm, lp_lat, 0);
                    healpix_sphere(lp_lon, lp_lat, xy_x, xy_y);
                    combine_caps(xy_x, xy_y, this->m_proj_parm.north_square, this->m_proj_parm.south_square, 0);
                }

                // INVERSE(e_rhealpix_inverse)  ellipsoid
                // Project coordinates from cartesian (x, y) to geographic (lon, lat)
                inline void inv(cartesian_type& xy_x, cartesian_type& xy_y, geographic_type& lp_lon, geographic_type& lp_lat) const
                {
                    /* Check whether (x, y) lies in the rHEALPix image. */
                    if (in_image(xy_x, xy_y, 1, this->m_proj_parm.north_square, this->m_proj_parm.south_square) == 0) {
                        lp_lon = HUGE_VAL;
                        lp_lat = HUGE_VAL;
                        throw proj_exception(-15);
                            return;
                    }
                    combine_caps(xy_x, xy_y, this->m_proj_parm.north_square, this->m_proj_parm.south_square, 1);
                    healpix_sphere_inverse(xy_x, xy_y, lp_lon, lp_lat);
                    lp_lat = auth_lat(this->params(), m_proj_parm, lp_lat, 1);
                }

                static inline std::string get_name()
                {
                    return "rhealpix_ellipsoid";
                }

            };

            // template class, using CRTP to implement forward/inverse
            template <typename Geographic, typename Cartesian, typename Parameters>
            struct base_rhealpix_spheroid : public base_t_fi<base_rhealpix_spheroid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>
            {

                 typedef double geographic_type;
                 typedef double cartesian_type;

                par_healpix m_proj_parm;

                inline base_rhealpix_spheroid(const Parameters& par)
                    : base_t_fi<base_rhealpix_spheroid<Geographic, Cartesian, Parameters>,
                     Geographic, Cartesian, Parameters>(*this, par) {}

                // FORWARD(s_rhealpix_forward)  sphere
                // Project coordinates from geographic (lon, lat) to cartesian (x, y)
                inline void fwd(geographic_type& lp_lon, geographic_type& lp_lat, cartesian_type& xy_x, cartesian_type& xy_y) const
                {
                    healpix_sphere(lp_lon, lp_lat, xy_x, xy_y);
                    combine_caps(xy_x, xy_y, this->m_proj_parm.north_square, this->m_proj_parm.south_square, 0);
                }

                // INVERSE(s_rhealpix_inverse)  sphere
                // Project coordinates from cartesian (x, y) to geographic (lon, lat)
                inline void inv(cartesian_type& xy_x, cartesian_type& xy_y, geographic_type& lp_lon, geographic_type& lp_lat) const
                {
                    /* Check whether (x, y) lies in the rHEALPix image. */
                    if (in_image(xy_x, xy_y, 1, this->m_proj_parm.north_square, this->m_proj_parm.south_square) == 0) {
                        lp_lon = HUGE_VAL;
                        lp_lat = HUGE_VAL;
                        throw proj_exception(-15);
                            return;
                    }
                    combine_caps(xy_x, xy_y, this->m_proj_parm.north_square, this->m_proj_parm.south_square, 1);
                    return healpix_sphere_inverse(xy_x, xy_y, lp_lon, lp_lat);
                }

                static inline std::string get_name()
                {
                    return "rhealpix_spheroid";
                }

            };

            // HEALPix
            template <typename Parameters>
            void setup_healpix(Parameters& par, par_healpix& proj_parm)
            {
                if (par.es) {
                    pj_authset(par.es, proj_parm.apa); /* For auth_lat(). */
                    proj_parm.qp = pj_qsfn(1.0, par.e, par.one_es); /* For auth_lat(). */
                    par.a = par.a*sqrt(0.5*proj_parm.qp); /* Set par.a to authalic radius. */
                    par.ra = 1.0/par.a;
                } else {
                }
            }

            // rHEALPix
            template <typename Parameters>
            void setup_rhealpix(Parameters& par, par_healpix& proj_parm)
            {
                proj_parm.north_square = pj_param(par.params,"inorth_square").i;
                proj_parm.south_square = pj_param(par.params,"isouth_square").i;
                /* Check for valid north_square and south_square inputs. */
                if (proj_parm.north_square < 0 || proj_parm.north_square > 3) {
                    throw proj_exception(-47);
                }
                if (proj_parm.south_square < 0 || proj_parm.south_square > 3) {
                    throw proj_exception(-47);
                }
                if (par.es) {
                    pj_authset(par.es, proj_parm.apa); /* For auth_lat(). */
                    proj_parm.qp = pj_qsfn(1.0, par.e, par.one_es); /* For auth_lat(). */
                    par.a = par.a*sqrt(0.5*proj_parm.qp); /* Set par.a to authalic radius. */
                    par.ra = 1.0/par.a;
                } else {
                }
            }

        }} // namespace detail::healpix
    #endif // doxygen

    /*!
        \brief HEALPix projection
        \ingroup projections
        \tparam Geographic latlong point type
        \tparam Cartesian xy point type
        \tparam Parameters parameter type
        \par Projection characteristics
         - Spheroid
         - Ellipsoid
        \par Example
        \image html ex_healpix.gif
    */
    template <typename Geographic, typename Cartesian, typename Parameters = parameters>
    struct healpix_ellipsoid : public detail::healpix::base_healpix_ellipsoid<Geographic, Cartesian, Parameters>
    {
        inline healpix_ellipsoid(const Parameters& par) : detail::healpix::base_healpix_ellipsoid<Geographic, Cartesian, Parameters>(par)
        {
            detail::healpix::setup_healpix(this->m_par, this->m_proj_parm);
        }
    };

    /*!
        \brief HEALPix projection
        \ingroup projections
        \tparam Geographic latlong point type
        \tparam Cartesian xy point type
        \tparam Parameters parameter type
        \par Projection characteristics
         - Spheroid
         - Ellipsoid
        \par Example
        \image html ex_healpix.gif
    */
    template <typename Geographic, typename Cartesian, typename Parameters = parameters>
    struct healpix_spheroid : public detail::healpix::base_healpix_spheroid<Geographic, Cartesian, Parameters>
    {
        inline healpix_spheroid(const Parameters& par) : detail::healpix::base_healpix_spheroid<Geographic, Cartesian, Parameters>(par)
        {
            detail::healpix::setup_healpix(this->m_par, this->m_proj_parm);
        }
    };

    /*!
        \brief rHEALPix projection
        \ingroup projections
        \tparam Geographic latlong point type
        \tparam Cartesian xy point type
        \tparam Parameters parameter type
        \par Projection characteristics
         - Spheroid
         - Ellipsoid
        \par Projection parameters
         - north_square (integer)
         - south_square (integer)
        \par Example
        \image html ex_rhealpix.gif
    */
    template <typename Geographic, typename Cartesian, typename Parameters = parameters>
    struct rhealpix_ellipsoid : public detail::healpix::base_rhealpix_ellipsoid<Geographic, Cartesian, Parameters>
    {
        inline rhealpix_ellipsoid(const Parameters& par) : detail::healpix::base_rhealpix_ellipsoid<Geographic, Cartesian, Parameters>(par)
        {
            detail::healpix::setup_rhealpix(this->m_par, this->m_proj_parm);
        }
    };

    /*!
        \brief rHEALPix projection
        \ingroup projections
        \tparam Geographic latlong point type
        \tparam Cartesian xy point type
        \tparam Parameters parameter type
        \par Projection characteristics
         - Spheroid
         - Ellipsoid
        \par Projection parameters
         - north_square (integer)
         - south_square (integer)
        \par Example
        \image html ex_rhealpix.gif
    */
    template <typename Geographic, typename Cartesian, typename Parameters = parameters>
    struct rhealpix_spheroid : public detail::healpix::base_rhealpix_spheroid<Geographic, Cartesian, Parameters>
    {
        inline rhealpix_spheroid(const Parameters& par) : detail::healpix::base_rhealpix_spheroid<Geographic, Cartesian, Parameters>(par)
        {
            detail::healpix::setup_rhealpix(this->m_par, this->m_proj_parm);
        }
    };

    #ifndef DOXYGEN_NO_DETAIL
    namespace detail
    {

        // Factory entry(s)
        template <typename Geographic, typename Cartesian, typename Parameters>
        class healpix_entry : public detail::factory_entry<Geographic, Cartesian, Parameters>
        {
            public :
                virtual projection<Geographic, Cartesian>* create_new(const Parameters& par) const
                {
                    if (par.es)
                        return new base_v_fi<healpix_ellipsoid<Geographic, Cartesian, Parameters>, Geographic, Cartesian, Parameters>(par);
                    else
                        return new base_v_fi<healpix_spheroid<Geographic, Cartesian, Parameters>, Geographic, Cartesian, Parameters>(par);
                }
        };

        template <typename Geographic, typename Cartesian, typename Parameters>
        class rhealpix_entry : public detail::factory_entry<Geographic, Cartesian, Parameters>
        {
            public :
                virtual projection<Geographic, Cartesian>* create_new(const Parameters& par) const
                {
                    if (par.es)
                        return new base_v_fi<rhealpix_ellipsoid<Geographic, Cartesian, Parameters>, Geographic, Cartesian, Parameters>(par);
                    else
                        return new base_v_fi<rhealpix_spheroid<Geographic, Cartesian, Parameters>, Geographic, Cartesian, Parameters>(par);
                }
        };

        template <typename Geographic, typename Cartesian, typename Parameters>
        inline void healpix_init(detail::base_factory<Geographic, Cartesian, Parameters>& factory)
        {
            factory.add_to_factory("healpix", new healpix_entry<Geographic, Cartesian, Parameters>);
            factory.add_to_factory("rhealpix", new rhealpix_entry<Geographic, Cartesian, Parameters>);
        }

    } // namespace detail
    #endif // doxygen

}}} // namespace boost::geometry::projections

#endif // BOOST_GEOMETRY_PROJECTIONS_HEALPIX_HPP

